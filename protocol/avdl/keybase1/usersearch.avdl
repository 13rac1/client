@namespace("keybase.1")
protocol userSearch {
    import idl "common.avdl";
    import idl "contacts.avdl";

    record APIUserKeybaseResult {
        string username;
        UID uid;
        @jsonkey("picture_url")
        union { null, string } pictureUrl;
        @jsonkey("full_name")
        union { null, string } fullName;
        @jsonkey("raw_score")
        double rawScore;
        union { null, string } stellar;
        @jsonkey("is_followee")
        boolean isFollowee;
    }

    record APIUserServiceResult {
        @jsonkey("service_name")
        string serviceName;
        string username;
        @jsonkey("picture_url")
        string pictureUrl;
        string bio;
        string location;
        @jsonkey("full_name")
        string fullName;
        union { null, boolean } confirmed;
    }

    record APIUserServiceSummary {
        @jsonkey("service_name")
        string serviceName;
        string username;
    }

    record ImpTofuSearchResult {
        string assertion;
        string label;
        string prettyName;
        string keybaseUsername; // keybase username if assertion resolves, empty if not
    }

    record APIUserSearchResult {
        double score;
        union { null, APIUserKeybaseResult } keybase;
        union { null, APIUserServiceResult } service;
        @jsonkey("services_summary")
        map<string, APIUserServiceSummary> servicesSummary;
        double rawScore;
    }

    record NonUserDetails {
        boolean isNonUser;
        string assertionValue; // name
        string assertionKey; // service
        string description; // "Twitter user", "Phone contact"
        union { null, ProcessedContact } contact;
        union { null, APIUserServiceResult } service;
        array<SizedImage> siteIcon;
        array<SizedImage> siteIconFull;
    }
    NonUserDetails getNonUserDetails(int sessionID, string assertion);

    enum ImpTofuSearchType {
        PHONE_0,
        EMAIL_1
    }

    variant ImpTofuQuery switch (ImpTofuSearchType t) {
        case PHONE: PhoneNumber;
        case EMAIL: EmailAddress;
    }

    enum ContactSourceType {
        PHONE_0,
        EMAIL_1
    }

    enum UserSearchSourceType {
        KEYBASE_0,
        SOCIAL_1,
        CONTACTS_2,
        TOFU_3
    }

    variant UserSearchSource switch (UserSearchSourceType t) {
        case SOCIAL: string;
        // case CONTACTS: ContactSourceType;
        // case TOFU: ContactSourceType;
        default: void;
    }

    record UserSearchResult {
        string id; // unique key

        // Assertion, for use in chat / team creation. NOTE: this is not
        // necessarily "${username}@${serviceName}"
        string assertion;

        string username; // Username on the service (or phone number, or e-mail, if from contacts)
        string serviceName; // Service which the result comes from

        // "Pretty name" for result rows and userboxes. For services and Keybase
        // it's always username. For contacts it depends on whether the contact is
        // on Keybase, and if we follow them or not.
        string prettyName;
        // "Label" / "subtitle" for result rows.
        string label;

        // Popup text when this user is selected to chat/team. Should be a
        // description of username and service, e.g. "michal on Hacker News"
        string bubbleText;

        // Username on Keybase, can be empty. E.g. twitter result which is also
        // proven by a Keybase user will have Keybase username. NOTE: Should not
        // be used for creating conversations / teams!
        string keybaseUsername;
        UID uid; // UID on Keybase if available - see above

        UserSearchSource source;
        // Map (serviceName -> username) of social account this user has.
        map<string, string> serviceMap;

        double score;
        double rawScore;
    }

    array<UserSearchResult> userSearch(string query, string service, int maxResults,
        boolean includeServicesSummary, boolean includeContacts,
        union { null, ImpTofuQuery } impTofuQuery);
}
